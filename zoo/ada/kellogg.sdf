module Main

exports
  sorts
        Compilation-unit Pragma Pragma-args-opt Pragma-arg Context-items-opt With-clause C-name-list Compound-name Use-clause Subtype-mark Attribute-id Library-item Private-opt Lib-pkg-spec-or-body Subprog-decl Def-id Generic-subp-inst Generic-inst Parenth-values Value Ranged-expr-s Ranged-expr Range-constraint Range Range-dots Range-attrib-ref Prefix Formal-part-opt Parameter-specification Def-ids-colon Defining-identifier-list Mode-opt Renames Name Is-operator Definable-operator-symbol Parenthesized-primary Extension-opt Is-separate-or-abstract-or-decl Separate-or-abstract Def-designator Designator Function-tail Func-formal-part-opt Func-param In-access-opt Spec-decl-part Pkg-spec-part Basic-declarative-items-opt Basic-declarative-items Basic-decl-item Task-type-or-single-decl Task-definition-opt Discrim-part-opt Discrim-part-text Known-discrim-part Empty-discrim-opt Discrim-part Discriminant-specifications Discriminant-specification Access-opt Init-opt Task-items-opt Entrydecls-repspecs-opt Entry-declaration Discrete-subtype-def-opt Discrete-subtype-definition Rep-spec Rep-spec-part Align-opt Comp-loc-s Private-task-items-opt Prot-type-or-single-decl Protected-definition Prot-op-decl-s Prot-op-decl Prot-member-decl-s Comp-decl Decl-common Type-def Enum-id-s Enumeration-literal-specification Range-constraint-opt Array-type-definition Index-or-discrete-range-s Index-or-discrete-range Component-subtype-def Aliased-opt Subtype-ind Constraint-opt Digits-constraint Delta-constraint Index-constraint Discrete-range Discriminant-constraint Discriminant-association Selector-names-opt Association-head Selector-name Access-type-definition Protected-opt Constant-all-opt Derived-or-private-or-record Abstract-opt Record-definition Component-list Component-items Empty-component-items Variant-part Discriminant-direct-name Variant-s Variant Choice-s Choice Discrete-with-range Mark-with-constraint Abstract-tagged-limited-opt Local-enum-name Enumeration-aggregate Aliased-constant-opt Generic-decl Generic-formal-part-opt Generic-formal-parameter Discriminable-type-definition Subprogram-default-opt Formal-package-actual-part-opt Subprog-decl-or-rename-or-inst-or-body Body-part Declarative-part Declarative-item Body-is Separate Pkg-body-part Block-body-opt Prot-op-bodies-opt Subprog-decl-or-body Block-body Handled-stmt-s Statements Statement Def-label-opt Null-stmt If-stmt Cond-clause Condition Elsifs-opt Else-opt Case-stmt Alternative-s Case-statement-alternative Loop-stmt Iteration-scheme-opt Reverse-opt Id-opt End-id-opt Statement-identifier Block Declare-opt Exit-stmt Label-name Return-stmt Goto-stmt Call-or-assignment Entry-body Entry-body-formal-part Entry-index-spec-opt Entry-barrier Entry-call-stmt Accept-stmt Entry-index-opt Delay-stmt Until-opt Select-stmt Triggering-alternative Abortable-part Entry-call-alternative Selective-accept Guard-opt Select-alternative Accept-alternative Delay-alternative Stmts-opt Or-select-opt Abort-stmt Except-handler-part-opt Exception-handler Identifier-colon-opt Except-choice-s Exception-choice Raise-stmt Requeue-stmt Operator-call Operator-call-tail Value-s Expression Relation Range-or-mark Simple-expression Signed-term Term Factor Primary Name-or-qualified Allocator Subunit Subprogram-body Package-body Task-body Protected-body ABORT ABS ABSTRACT ACCEPT ACCESS ALIASED ALL AND ARRAY AT BEGIN BODY CASE CONSTANT DECLARE DELAY DELTA DIGITS DO ELSE ELSIF END ENTRY EXCEPTION EXIT FOR FUNCTION GENERIC GOTO IF IN IS LIMITED LOOP MOD NEW NOT NuLL OF OR OTHERS OUT PACKAGE PRAGMA PRIVATE PROCEDURE PROTECTED RAISE RANGE RECORD REM RENAMES REQUEUE RETURN REVERSE SELECT SEPARATE SUBTYPE TAGGED TASK TERMINATE THEN TYPE UNTIL USE WHEN WHILE WITH XOR COMMENT-INTRO DOT-DOT LT-LT BOX GT-GT ASSIGN RIGHT-SHAFT NE LE GE EXPON PIPE CONCAT DOT EQ LT- GT PLUS MINUS STAR DIV LPAREN RPAREN COLON COMMA SEMI TIC IDENTIFIER CHARACTER-LITERAL CHAR-STRING NUMERIC-LIT DIGIT EXPONENT EXTENDED-DIGIT BASED-INTEGER WS- COMMENT 
  context-free syntax
        Context-items-opt (Library-item | Subunit) Pragma* -> Compilation-unit

        PRAGMA IDENTIFIER Pragma-args-opt SEMI -> Pragma

        (LPAREN Pragma-arg (COMMA Pragma-arg)* RPAREN)? -> Pragma-args-opt

        (IDENTIFIER RIGHT-SHAFT)? Expression -> Pragma-arg

        Pragma* (With-clause (Use-clause | Pragma)*)* -> Context-items-opt

        w::WITH C-name-list SEMI -> With-clause

        Compound-name (COMMA Compound-name)* -> C-name-list

        IDENTIFIER (DOT IDENTIFIER)* -> Compound-name

        u::USE ((TYPE Subtype-mark (COMMA Subtype-mark)*) | C-name-list) SEMI -> Use-clause

        Compound-name (TIC Attribute-id)? -> Subtype-mark

        RANGE
		| DIGITS
		| DELTA
		| ACCESS
		| IDENTIFIER -> Attribute-id

        Private-opt (Lib-pkg-spec-or-body | Subprog-decl-or-rename-or-inst-or-body | Generic-decl) -> Library-item

        PRIVATE? -> Private-opt

        pkg::PACKAGE ((BODY Def-id IS Pkg-body-part End-id-opt SEMI) | (Def-id Spec-decl-part)) -> Lib-pkg-spec-or-body

        p::PROCEDURE Def-id (Generic-subp-inst | (Formal-part-opt (Renames | Is-separate-or-abstract-or-decl) SEMI))
		| f::FUNCTION Def-designator (Generic-subp-inst | (Function-tail (Renames | Is-separate-or-abstract-or-decl) SEMI)) -> Subprog-decl

        cn::Compound-name
		| n::IDENTIFIER -> Def-id

        IS Generic-inst SEMI -> Generic-subp-inst

        NEW Compound-name (LPAREN Value-s RPAREN)? -> Generic-inst

        LPAREN Value (COMMA Value)* RPAREN -> Parenth-values

        OTHERS RIGHT-SHAFT Expression
		| Ranged-expr-s (RIGHT-SHAFT Expression)? -> Value

        Ranged-expr (PIPE Ranged-expr)* -> Ranged-expr-s

        Expression ((DOT-DOT Simple-expression) | (RANGE Range))? -> Ranged-expr

        RANGE Range -> Range-constraint

        Range-dots
		| Range-attrib-ref -> Range

        Simple-expression DOT-DOT Simple-expression -> Range-dots

        Prefix TIC r::RANGE (LPAREN Expression RPAREN)? -> Range-attrib-ref

        IDENTIFIER ((DOT (ALL | IDENTIFIER)) | (p::LPAREN Value-s RPAREN))* -> Prefix

        (LPAREN Parameter-specification (SEMI Parameter-specification)* RPAREN)? -> Formal-part-opt

        Def-ids-colon Mode-opt Subtype-mark Init-opt -> Parameter-specification

        Defining-identifier-list COLON -> Def-ids-colon

        IDENTIFIER (COMMA IDENTIFIER)* -> Defining-identifier-list

        ((IN OUT?) | OUT | ACCESS)? -> Mode-opt

        RENAMES (Name | dummy::Definable-operator-symbol) -> Renames

        IDENTIFIER ((DOT (ALL | IDENTIFIER | CHARACTER-LITERAL | dummy::Is-operator)) | (p::LPAREN Value-s RPAREN) | (TIC Attribute-id))* -> Name

        op::CHAR-STRING -> Is-operator

        op::CHAR-STRING -> Definable-operator-symbol

        pp::LPAREN ((NuLL RECORD) | (Value-s Extension-opt)) RPAREN -> Parenthesized-primary

        (WITH ((NuLL RECORD) | Value-s))? -> Extension-opt

        IS Separate-or-abstract
		|  -> Is-separate-or-abstract-or-decl

        SEPARATE
		| ABSTRACT -> Separate-or-abstract

        n::Compound-name
		| d::Designator -> Def-designator

        op::Definable-operator-symbol
		| n::IDENTIFIER -> Designator

        Func-formal-part-opt RETURN Subtype-mark -> Function-tail

        (LPAREN Func-param (SEMI Func-param)* RPAREN)? -> Func-formal-part-opt

        Def-ids-colon In-access-opt Subtype-mark Init-opt -> Func-param

        (IN | ACCESS)? -> In-access-opt

        ((IS (Generic-inst | Pkg-spec-part)) | Renames) SEMI -> Spec-decl-part

        Basic-declarative-items-opt (PRIVATE Basic-declarative-items-opt)? End-id-opt -> Pkg-spec-part

        (Basic-decl-item | Pragma)* -> Basic-declarative-items-opt

        (Basic-decl-item | Pragma)+ -> Basic-declarative-items

        pkg::PACKAGE Def-id Spec-decl-part
		| tsk::TASK Task-type-or-single-decl
		| pro::PROTECTED Prot-type-or-single-decl SEMI
		| Subprog-decl
		| Decl-common -> Basic-decl-item

        TYPE Def-id Discrim-part-opt Task-definition-opt
		| Def-id Task-definition-opt -> Task-type-or-single-decl

        IS Task-items-opt Private-task-items-opt End-id-opt SEMI
		| SEMI -> Task-definition-opt

        Discrim-part-text? -> Discrim-part-opt

        LPAREN (BOX | Discriminant-specifications) RPAREN -> Discrim-part-text

        LPAREN Discriminant-specifications RPAREN -> Known-discrim-part

         -> Empty-discrim-opt

        Discrim-part-text -> Discrim-part

        Discriminant-specification (SEMI Discriminant-specification)* -> Discriminant-specifications

        Def-ids-colon Access-opt Subtype-mark Init-opt -> Discriminant-specification

        ACCESS? -> Access-opt

        (ASSIGN Expression)? -> Init-opt

        Pragma* Entrydecls-repspecs-opt -> Task-items-opt

        (Entry-declaration (Pragma | Rep-spec)*)* -> Entrydecls-repspecs-opt

        e::ENTRY IDENTIFIER Discrete-subtype-def-opt Formal-part-opt SEMI -> Entry-declaration

        LPAREN Discrete-subtype-definition
		|  -> Discrete-subtype-def-opt

        Range
		| Subtype-ind -> Discrete-subtype-definition

        r::FOR Subtype-mark USE Rep-spec-part SEMI -> Rep-spec

        RECORD Align-opt Comp-loc-s END RECORD
		| AT Expression
		| Expression -> Rep-spec-part

        (AT MOD Expression SEMI)? -> Align-opt

        (Pragma | (Subtype-mark AT Expression RANGE Range SEMI))* -> Comp-loc-s

        (PRIVATE Pragma* Entrydecls-repspecs-opt)? -> Private-task-items-opt

        TYPE Def-id Discrim-part-opt Protected-definition
		| Def-id Protected-definition -> Prot-type-or-single-decl

        IS Prot-op-decl-s (PRIVATE Prot-member-decl-s)? End-id-opt -> Protected-definition

        Prot-op-decl* -> Prot-op-decl-s

        Entry-declaration
		| p::PROCEDURE Def-id Formal-part-opt SEMI
		| f::FUNCTION Def-designator Function-tail SEMI
		| Rep-spec
		| Pragma -> Prot-op-decl

        (Prot-op-decl | Comp-decl)* -> Prot-member-decl-s

        Def-ids-colon Component-subtype-def Init-opt SEMI -> Comp-decl

        t::TYPE IDENTIFIER ((IS Type-def) | (Discrim-part ((IS Derived-or-private-or-record) | )) | Empty-discrim-opt) SEMI
		| s::SUBTYPE IDENTIFIER IS Subtype-ind SEMI
		| Generic-decl
		| Use-clause
		| r::FOR ((Local-enum-name USE) | (Subtype-mark USE Rep-spec-part)) SEMI
		| IDENTIFIER erd::COLON EXCEPTION RENAMES Compound-name
		| IDENTIFIER ord::COLON Subtype-mark RENAMES Name
		| Defining-identifier-list od::COLON (EXCEPTION | (CONSTANT ASSIGN) | (Aliased-constant-opt ((Array-type-definition Init-opt) | (Subtype-ind Init-opt)))) SEMI -> Decl-common

        LPAREN Enum-id-s RPAREN
		| RANGE Range
		| MOD Expression
		| DIGITS Expression Range-constraint-opt
		| DELTA Expression ((RANGE Range) | (DIGITS Expression Range-constraint-opt))
		| Array-type-definition
		| Access-type-definition
		| Empty-discrim-opt Derived-or-private-or-record -> Type-def

        Enumeration-literal-specification (COMMA Enumeration-literal-specification)* -> Enum-id-s

        IDENTIFIER
		| CHARACTER-LITERAL -> Enumeration-literal-specification

        Range-constraint? -> Range-constraint-opt

        ARRAY LPAREN Index-or-discrete-range-s RPAREN OF Component-subtype-def -> Array-type-definition

        Index-or-discrete-range (COMMA Index-or-discrete-range)* -> Index-or-discrete-range-s

        Simple-expression ((DOT-DOT Simple-expression) | (RANGE (BOX | Range)))? -> Index-or-discrete-range

        Aliased-opt Subtype-ind -> Component-subtype-def

        ALIASED? -> Aliased-opt

        Subtype-mark Constraint-opt -> Subtype-ind

        (Range-constraint | Digits-constraint | Delta-constraint | Index-constraint | Discriminant-constraint)? -> Constraint-opt

        d::DIGITS Expression Range-constraint-opt -> Digits-constraint

        d::DELTA Expression Range-constraint-opt -> Delta-constraint

        p::LPAREN Discrete-range (COMMA Discrete-range)* RPAREN -> Index-constraint

        Range
		| Subtype-ind -> Discrete-range

        p::LPAREN Discriminant-association (COMMA Discriminant-association)* RPAREN -> Discriminant-constraint

        Selector-names-opt Expression -> Discriminant-association

        Association-head
		|  -> Selector-names-opt

        Selector-name (PIPE Selector-name)* RIGHT-SHAFT -> Association-head

        IDENTIFIER -> Selector-name

        ACCESS ((Protected-opt ((PROCEDURE Formal-part-opt) | (FUNCTION Func-formal-part-opt RETURN Subtype-mark))) | (Constant-all-opt Subtype-ind)) -> Access-type-definition

        PROTECTED? -> Protected-opt

        (CONSTANT | ALL)? -> Constant-all-opt

        Abstract-opt NEW Subtype-ind WITH
		| NEW Subtype-ind
		| Abstract-tagged-limited-opt (PRIVATE | Record-definition) -> Derived-or-private-or-record

        ABSTRACT? -> Abstract-opt

        RECORD Component-list END RECORD
		| NuLL RECORD -> Record-definition

        NuLL SEMI
		| Component-items Variant-part?
		| Empty-component-items Variant-part -> Component-list

        (Pragma | Comp-decl)+ -> Component-items

         -> Empty-component-items

        c::CASE Discriminant-direct-name IS Variant-s END CASE SEMI -> Variant-part

        IDENTIFIER -> Discriminant-direct-name

        Variant+ -> Variant-s

        w::WHEN Choice-s RIGHT-SHAFT Component-list -> Variant

        Choice (PIPE Choice)* -> Choice-s

        OTHERS
		| Discrete-with-range
		| Expression -> Choice

        Mark-with-constraint
		| Range -> Discrete-with-range

        Subtype-mark Range-constraint -> Mark-with-constraint

        ((ABSTRACT TAGGED) | TAGGED)? LIMITED? -> Abstract-tagged-limited-opt

        IDENTIFIER -> Local-enum-name

        Parenth-values -> Enumeration-aggregate

        ALIASED? CONSTANT? -> Aliased-constant-opt

        g::GENERIC Generic-formal-part-opt ((PACKAGE Def-id (Renames | (IS Pkg-spec-part))) | (PROCEDURE Def-id Formal-part-opt (Renames | )) | (FUNCTION Def-designator Function-tail (Renames | ))) SEMI -> Generic-decl

        (Use-clause | Pragma | Generic-formal-parameter)* -> Generic-formal-part-opt

        ((t::TYPE Def-id ((IS ((LPAREN BOX RPAREN) | (RANGE BOX) | (MOD BOX) | (DELTA BOX ((DIGITS BOX) | )) | (DIGITS BOX) | Array-type-definition | Access-type-definition | (Empty-discrim-opt Discriminable-type-definition))) | (Discrim-part IS Discriminable-type-definition))) | (w::WITH ((PROCEDURE Def-id Formal-part-opt Subprogram-default-opt) | (FUNCTION Def-designator Function-tail Subprogram-default-opt) | (PACKAGE Def-id IS NEW Compound-name Formal-package-actual-part-opt))) | Parameter-specification) SEMI -> Generic-formal-parameter

        Abstract-opt NEW Subtype-ind WITH
		| NEW Subtype-ind
		| Abstract-tagged-limited-opt PRIVATE -> Discriminable-type-definition

        (IS (BOX | Name))? -> Subprogram-default-opt

        (LPAREN (BOX | Defining-identifier-list) RPAREN)? -> Formal-package-actual-part-opt

        p::PROCEDURE Def-id (Generic-subp-inst | (Formal-part-opt (Renames | (IS (Separate-or-abstract | Body-part)) | ) SEMI))
		| f::FUNCTION Def-designator (Generic-subp-inst | (Function-tail (Renames | (IS (Separate-or-abstract | Body-part)) | ) SEMI)) -> Subprog-decl-or-rename-or-inst-or-body

        Declarative-part Block-body End-id-opt -> Body-part

        (Pragma | Declarative-item)* -> Declarative-part

        pkg::PACKAGE ((Body-is (Separate | (Pkg-body-part End-id-opt)) SEMI) | (Def-id Spec-decl-part))
		| tsk::TASK ((Body-is (Separate | Body-part) SEMI) | Task-type-or-single-decl)
		| pro::PROTECTED ((Body-is (Separate | (Prot-op-bodies-opt End-id-opt))) | Prot-type-or-single-decl) SEMI
		| Subprog-decl-or-rename-or-inst-or-body
		| Decl-common -> Declarative-item

        BODY Def-id IS -> Body-is

        SEPARATE -> Separate

        Declarative-part Block-body-opt -> Pkg-body-part

        (BEGIN Handled-stmt-s)? -> Block-body-opt

        (Entry-body | Subprog-decl-or-body | Pragma)* -> Prot-op-bodies-opt

        p::PROCEDURE Def-id Formal-part-opt ((IS Body-part) | ) SEMI
		| f::FUNCTION Def-designator Function-tail ((IS Body-part) | ) SEMI -> Subprog-decl-or-body

        b::BEGIN Handled-stmt-s -> Block-body

        Statements Except-handler-part-opt -> Handled-stmt-s

        (Pragma | Statement)+ -> Statements

        Def-label-opt (Null-stmt | Exit-stmt | Return-stmt | Goto-stmt | Delay-stmt | Abort-stmt | Raise-stmt | Requeue-stmt | Accept-stmt | Select-stmt | If-stmt | Case-stmt | (Loop-stmt SEMI) | (Block END SEMI) | (Statement-identifier ((Loop-stmt Id-opt SEMI) | (Block End-id-opt SEMI))) | Call-or-assignment) -> Statement

        (LT-LT IDENTIFIER GT-GT)? -> Def-label-opt

        s::NuLL SEMI -> Null-stmt

        s::IF Cond-clause Elsifs-opt Else-opt END IF SEMI -> If-stmt

        Condition c::THEN Statements -> Cond-clause

        Expression -> Condition

        (ELSIF Cond-clause)* -> Elsifs-opt

        (ELSE Statements)? -> Else-opt

        s::CASE Expression IS Alternative-s END CASE SEMI -> Case-stmt

        Case-statement-alternative+ -> Alternative-s

        s::WHEN Choice-s RIGHT-SHAFT Statements -> Case-statement-alternative

        Iteration-scheme-opt LOOP Statements END LOOP -> Loop-stmt

        ((WHILE Condition) | (FOR IDENTIFIER IN Reverse-opt Discrete-subtype-definition))? -> Iteration-scheme-opt

        REVERSE? -> Reverse-opt

        endid::Definable-operator-symbol
		| n::Compound-name
		|  -> Id-opt

        END Id-opt -> End-id-opt

        n::IDENTIFIER COLON -> Statement-identifier

        Declare-opt Block-body -> Block

        (DECLARE Declarative-part)? -> Declare-opt

        s::EXIT Label-name? (WHEN Condition)? SEMI -> Exit-stmt

        IDENTIFIER -> Label-name

        s::RETURN Expression? SEMI -> Return-stmt

        s::GOTO Label-name SEMI -> Goto-stmt

        Name ((ASSIGN Expression) | ) SEMI -> Call-or-assignment

        e::ENTRY Def-id Entry-body-formal-part Entry-barrier IS Body-part SEMI -> Entry-body

        Entry-index-spec-opt Formal-part-opt -> Entry-body-formal-part

        LPAREN FOR Def-id IN Discrete-subtype-definition
		|  -> Entry-index-spec-opt

        WHEN Condition -> Entry-barrier

        Name SEMI -> Entry-call-stmt

        a::ACCEPT Def-id Entry-index-opt Formal-part-opt ((DO Handled-stmt-s End-id-opt SEMI) | SEMI) -> Accept-stmt

        LPAREN Expression
		|  -> Entry-index-opt

        d::DELAY Until-opt Expression SEMI -> Delay-stmt

        UNTIL? -> Until-opt

        s::SELECT ((Triggering-alternative THEN ABORT) | Selective-accept | (Entry-call-alternative ((OR Delay-alternative) | (ELSE Statements)))) END SELECT SEMI -> Select-stmt

        (Delay-stmt | Entry-call-stmt) Stmts-opt -> Triggering-alternative

        Stmts-opt -> Abortable-part

        Entry-call-stmt Stmts-opt -> Entry-call-alternative

        Guard-opt Select-alternative Or-select-opt Else-opt -> Selective-accept

        (WHEN Condition RIGHT-SHAFT Pragma*)? -> Guard-opt

        Accept-alternative
		| Delay-alternative
		| t::TERMINATE SEMI -> Select-alternative

        Accept-stmt Stmts-opt -> Accept-alternative

        Delay-stmt Stmts-opt -> Delay-alternative

        (Pragma | Statement)* -> Stmts-opt

        (OR Guard-opt Select-alternative)* -> Or-select-opt

        a::ABORT Name (COMMA Name)* SEMI -> Abort-stmt

        (EXCEPTION Exception-handler+)? -> Except-handler-part-opt

        w::WHEN Identifier-colon-opt Except-choice-s RIGHT-SHAFT Statements -> Exception-handler

        (IDENTIFIER COLON)? -> Identifier-colon-opt

        Exception-choice (PIPE Exception-choice)* -> Except-choice-s

        Compound-name
		| OTHERS -> Exception-choice

        r::RAISE Compound-name? SEMI -> Raise-stmt

        r::REQUEUE Name (WITH ABORT)? SEMI -> Requeue-stmt

        cs::CHAR-STRING Operator-call-tail -> Operator-call

        LPAREN Value-s RPAREN -> Operator-call-tail

        Value (COMMA Value)* -> Value-s

        Relation ((a::AND THEN? Relation) | (o::OR ELSE? Relation) | (XOR Relation))* -> Expression

        Simple-expression ((IN Range-or-mark) | (n::NOT IN Range-or-mark) | (EQ Simple-expression) | (NE Simple-expression) | (LT- Simple-expression) | (LE Simple-expression) | (GT Simple-expression) | (GE Simple-expression))? -> Relation

        Range
		| Subtype-mark -> Range-or-mark

        Signed-term ((PLUS Signed-term) | (MINUS Signed-term) | (CONCAT Signed-term))* -> Simple-expression

        p::PLUS Term
		| m::MINUS Term
		| Term -> Signed-term

        Factor ((STAR Factor) | (DIV Factor) | (MOD Factor) | (REM Factor))* -> Term

        NOT Primary
		| ABS Primary
		| Primary (EXPON Primary)? -> Factor

        Name-or-qualified
		| Parenthesized-primary
		| Allocator
		| NuLL
		| NUMERIC-LIT
		| CHARACTER-LITERAL
		| cs::CHAR-STRING Operator-call-tail? -> Primary

        IDENTIFIER ((DOT (ALL | IDENTIFIER | CHARACTER-LITERAL | dummy::Is-operator)) | (p::LPAREN Value-s RPAREN) | (TIC (Parenthesized-primary | Attribute-id)))* -> Name-or-qualified

        n::NEW Name-or-qualified -> Allocator

        sep::SEPARATE LPAREN Compound-name RPAREN (Subprogram-body | Package-body | Task-body | Protected-body) -> Subunit

        p::PROCEDURE Def-id Formal-part-opt IS Body-part SEMI
		| f::FUNCTION Function-tail IS Body-part SEMI -> Subprogram-body

        p::PACKAGE Body-is Pkg-body-part End-id-opt SEMI -> Package-body

        t::TASK Body-is Body-part SEMI -> Task-body

        p::PROTECTED Body-is Prot-op-bodies-opt End-id-opt SEMI -> Protected-body

        "abort" -> ABORT

        "abs" -> ABS

        "abstract" -> ABSTRACT

        "accept" -> ACCEPT

        "access" -> ACCESS

        "aliased" -> ALIASED

        "all" -> ALL

        "and" -> AND

        "array" -> ARRAY

        "at" -> AT

        "begin" -> BEGIN

        "body" -> BODY

        "case" -> CASE

        "constant" -> CONSTANT

        "declare" -> DECLARE

        "delay" -> DELAY

        "delta" -> DELTA

        "digits" -> DIGITS

        "do" -> DO

        "else" -> ELSE

        "elsif" -> ELSIF

        "end" -> END

        "entry" -> ENTRY

        "exception" -> EXCEPTION

        "exit" -> EXIT

        "for" -> FOR

        "function" -> FUNCTION

        "generic" -> GENERIC

        "goto" -> GOTO

        "if" -> IF

        "in" -> IN

        "is" -> IS

        "limited" -> LIMITED

        "loop" -> LOOP

        "mod" -> MOD

        "new" -> NEW

        "not" -> NOT

        "null" -> NuLL

        "of" -> OF

        "or" -> OR

        "others" -> OTHERS

        "out" -> OUT

        "package" -> PACKAGE

        "pragma" -> PRAGMA

        "private" -> PRIVATE

        "procedure" -> PROCEDURE

        "protected" -> PROTECTED

        "raise" -> RAISE

        "range" -> RANGE

        "record" -> RECORD

        "rem" -> REM

        "renames" -> RENAMES

        "requeue" -> REQUEUE

        "return" -> RETURN

        "reverse" -> REVERSE

        "select" -> SELECT

        "separate" -> SEPARATE

        "subtype" -> SUBTYPE

        "tagged" -> TAGGED

        "task" -> TASK

        "terminate" -> TERMINATE

        "then" -> THEN

        "type" -> TYPE

        "until" -> UNTIL

        "use" -> USE

        "when" -> WHEN

        "while" -> WHILE

        "with" -> WITH

        "xor" -> XOR

        "--" -> COMMENT-INTRO

        ".." -> DOT-DOT

        "<<" -> LT-LT

        "<>" -> BOX

        ">>" -> GT-GT

        ":=" -> ASSIGN

        "=>" -> RIGHT-SHAFT

        "/=" -> NE

        "<=" -> LE

        ">=" -> GE

        "**" -> EXPON

        "|" -> PIPE

        "&" -> CONCAT

        "." -> DOT

        "=" -> EQ

        "<" -> LT-

        ">" -> GT

        "+" -> PLUS

        "-" -> MINUS

        "*" -> STAR

        "/" -> DIV

        "(" -> LPAREN

        ")" -> RPAREN

        ":" -> COLON

        "," -> COMMA

        ";" -> SEMI

        "'" -> TIC

        ("a" | "b" | "c" | "d" | "e" | "f" | "g" | "h" | "i" | "j" | "k" | "l" | "m" | "n" | "o" | "p" | "q" | "r" | "s" | "t" | "u" | "v" | "w" | "x" | "y" | "z") ("_"? ("a" | "b" | "c" | "d" | "e" | "f" | "g" | "h" | "i" | "j" | "k" | "l" | "m" | "n" | "o" | "p" | "q" | "r" | "s" | "t" | "u" | "v" | "w" | "x" | "y" | "z" | "0" | "1" | "2" | "3" | "4" | "5" | "6" | "7" | "8" | "9"))* -> IDENTIFIER

        "'" ANY "'" -> CHARACTER-LITERAL

        """ ANY* """ -> CHAR-STRING

        DIGIT+ (("#" BASED-INTEGER ("." BASED-INTEGER)? "#") | ("_" DIGIT+)+)? (("." DIGIT+ ("_" DIGIT+)* EXPONENT?) | EXPONENT)? -> NUMERIC-LIT

        "0"
		| "1"
		| "2"
		| "3"
		| "4"
		| "5"
		| "6"
		| "7"
		| "8"
		| "9" -> DIGIT

        "e" ("+" | "-")? DIGIT+ -> EXPONENT

        DIGIT
		| "a"
		| "b"
		| "c"
		| "d"
		| "e"
		| "f" -> EXTENDED-DIGIT

        EXTENDED-DIGIT ("_"? EXTENDED-DIGIT)* -> BASED-INTEGER

        " "
		| "\t"
		| "\f"
		| "\r\n"
		| "\r"
		| "\n" -> WS-

        COMMENT-INTRO ANY* ("\n" | ("\r" "\n"?)) -> COMMENT
