program = statement* ;
statement = includeStatement ;
statement = keysStatement ;
statement = compoundsStatement ;
statement = commentsStatement ;
statement = tokensStatement ;
statement = defineStatement ;
statement = redefineStatement ;
statement = ruleStatement ;
statement = functionStatement ;
statement = externalStatement ;
statement = comment NL ;
includeStatement = 'include' stringlit NL ;
keysStatement = 'keys' NL IN keyword* EX NL 'end' 'keys' NL NL ;
keyword = literal SP ;
keyword = key SP ;
compoundsStatement = 'compounds' NL IN compound* EX NL 'end' 'compounds' NL NL ;
compound = literal SP ;
commentsStatement = 'comments' NL IN commentConvention* EX 'end' 'comments' NL NL ;
commentConvention = literal SP literal NL ;
commentConvention = literal NL ;
tokensStatement = 'tokens' NL IN tokenPattern* EX 'end' 'tokens' NL NL ;
tokenPattern = typeid TAB_24 stringlit NL ;
tokenPattern = TAB_16 '|' TAB_24 stringlit NL ;
tokenPattern = typeid TAB_16 '...'? '|' TAB_24 stringlit NL ;
tokenPattern = typeid TAB_16 '+' TAB_24 stringlit NL ;
tokenPattern = comment NL ;
defineStatement = 'define' typeid NL IN IN literalOrType* NL barLiteralsAndTypes* EX EX 'end' 'define' NL NL RESET ;
redefineStatement = 'redefine' typeid NL IN IN dotDotDotBar? literalOrType* NL barLiteralsAndTypes* barDotDotDot? EX EX 'end' redefineOrDefine NL NL RESET ;
redefineOrDefine = 'redefine' ;
redefineOrDefine = 'define' ;
RESET = EX EX EX EX EX EX EX EX EX ;
dotDotDotBar = '...' EX NL '|' TAB IN ;
barDotDotDot = EX '|' TAB IN '...' NL ;
barLiteralsAndTypes = EX '|' TAB IN literalOrType* NL ;
literalOrType = type SP ;
literalOrType = literal SP ;
type = formatCues ;
type = '[' typeSpec ']' ;
formatCues = IN IN formatCue+ EX EX optNL? ;
optNL = literalOrType NL ;
formatCue = '[' formatId ']' ;
formatId = 'NL' ;
formatId = 'IN' IN ;
formatId = 'EX' EX ;
typeSpec = typeModifier? typeid typeRepeater? ;
typeSpec = '!' ;
typeModifier = 'opt' ;
typeModifier = 'repeat' ;
typeModifier = 'list' ;
typeModifier = 'attr' ;
typeModifier = 'see' ;
typeModifier = 'not' ;
typeModifier = 'push' ;
typeModifier = 'pop' ;
typeModifier = ':' ;
typeModifier = '~' ;
typeModifier = '>' ;
typeModifier = '<' ;
typeRepeater = '+' ;
typeRepeater = '*' ;
typeRepeater = '?' ;
typeRepeater = ',' ;
typeRepeater = ',+' ;
typeidOrQuotedLiteral = typeid ;
typeidOrQuotedLiteral = quotedLiteral ;
ruleStatement = 'rule' ruleid formalArgument* NL IN IN constructDeconstructImportExportOrCondition* EX skippingType? 'replace' dollarStar? SP type NL IN pattern constructDeconstructImportExportOrCondition* EX 'by' NL IN replacement EX EX 'end' 'rule' NL NL ;
ruleStatement = 'rule' ruleid formalArgument* NL IN IN constructDeconstructImportExportOrCondition* EX skippingType? 'match' dollarStar? SP type NL IN pattern EX EX constructDeconstructImportExportOrCondition* 'end' 'rule' NL NL ;
functionStatement = 'function' ruleid formalArgument* NL IN IN constructDeconstructImportExportOrCondition* EX skippingType? 'replace' dollarStar? SP type NL IN pattern constructDeconstructImportExportOrCondition* EX 'by' NL IN replacement EX EX 'end' 'function' NL NL ;
functionStatement = 'function' ruleid formalArgument* NL IN IN constructDeconstructImportExportOrCondition* EX skippingType? 'match' dollarStar? SP type NL IN pattern constructDeconstructImportExportOrCondition* EX EX 'end' 'function' NL NL ;
dollarStar = SP '$' ;
dollarStar = SP '*' ;
externalStatement = 'external' 'rule' ruleid formalArgument* NL NL ;
externalStatement = 'external' 'function' ruleid formalArgument* NL NL ;
formalArgument = varid SP type commentNL* ;
constructDeconstructImportExportOrCondition = constructor ;
constructDeconstructImportExportOrCondition = deconstructor ;
constructDeconstructImportExportOrCondition = condition ;
constructDeconstructImportExportOrCondition = importer ;
constructDeconstructImportExportOrCondition = exporter ;
constructDeconstructImportExportOrCondition = EX comment NL IN ;
constructor = EX 'construct' varid SP type NL IN replacement ;
deconstructor = EX skippingType? 'deconstruct' 'not'? '*'? type? varid NL IN pattern ;
condition = EX 'where' 'not'? 'all'? NL IN commentNL* expression NL ;
condition = EX 'assert' 'not'? 'all'? NL IN commentNL* expression NL ;
importer = EX 'import' varid type? NL IN pattern? ;
exporter = EX 'export' varid type? NL IN replacement? ;
skippingType = 'skipping' SP type commentNL* ;
pattern = literalOrVariable* NL ;
literalOrVariable = literal SP ;
literalOrVariable = varid SP type SP ;
literalOrVariable = varid SP ;
replacement = literalOrExpression* NL ;
literalOrExpression = literal SP ;
literalOrExpression = expression SP ;
expression = varid ruleApplications? ;
ruleApplications = IN IN commentNL* ruleApplication+ EX EX ruleoptNL? ;
ruleoptNL = literalOrExpression NL ;
ruleApplication = SP '[' ruleid varidOrLiteral* eachArgs? ']' commentNL* ;
ruleApplication = SP lengthrule varidOrLiteral* eachArgs? ']' commentNL* ;
commentNL = SP SP comment NEWoptNL? ;
NEWoptNL = NL ;
eachArgs = SP 'each' varidOrLiteral* ;
varidOrLiteral = SP varid ;
varidOrLiteral = SP literal ;
literal = quotedLiteral ;
literal = unquotedLiteral ;
literal = SP comment NEWoptNL? ;
quotedLiteral = ''' unquotedLiteral ;
quotedLiteral = ''' key ;
unquotedLiteral = SP ''' ;
unquotedLiteral = token ;
varid = id ;
typeid = id ;
typeid = SP literal ;
ruleid = id ;
ruleid = special ;
ruleid = '#' ;
ruleid = key ;
